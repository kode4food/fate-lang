import nodeunit

let data1 = {
  "name": "World",
  "title": "Famous People",
  "people" : [
    { "name": "Larry", "age": 50, "brothers": [] },
    { "name": "Curly", "age": 45, "brothers": ["Moe", "Shemp"] },
    { "name": "Moe", "age": 58, "brothers": ["Curly", "Shemp"] }
  ]
}

def relational(test)
  let isTrue = test.equal(?, true)
  let isFalse = test.equal(?, false)

  10 * 99 > 900                  | isTrue
  100 / 5 >= 30                  | isFalse
  99 mod 6 >= 3                  | isTrue
  33 * 3 mod 6 <= 2              | isFalse
  data1.people[0].age * 2 > 99   | isTrue
  data1.people[0].age / 2 < 24   | isFalse
  100 / data1.people[0].age >= 2 | isTrue
  3 * data1.people[0].age <= 149 | isFalse
  test.done()
end

def equality(test)
  let isTrue = test.equal(?, true)
  let isFalse = test.equal(?, false)

  10 * 99 = 990                  | isTrue
  100 / 5 != 19                  | isTrue
  99 mod 6 = 3                   | isTrue
  33 * 3 mod 6 != 2              | isTrue
  data1.people[0].age * 2 = 99   | isFalse
  data1.people[0].age / 2 != 25  | isFalse
  100 / data1.people[0].age = 2  | isTrue
  3 * data1.people[0].age != 149 | isTrue
  test.done()
end

let data2 = {
  numbers: [1,10,30],
  names: ['bill', 'ted'],
  person: {age:43, name:'Thom'},
  stringValue: "a name value"
}

def inEvaluation(test)
  let isTrue = test.equal(?, true)
  let isFalse = test.equal(?, false)

  10 in [1,10,30]                    | isTrue
  10 in data2.numbers                | isTrue
  'name' in {age:43, name:'Thom'}    | isTrue
  'name' in data2.person             | isTrue
  'name' in 'a name value'           | isFalse
  'name' in data2.stringValue        | isFalse
  'fred' in ['bill', 'ted']          | isFalse
  'fred' in data2.names              | isFalse
  'nothing' in {age:43, name:'Thom'} | isFalse
  'nothing' in data2.person          | isFalse
  test.done()
end

let data3 = {
  numbers: [1,10,30],
  names: ['bill', 'ted'],
  person: {age:43, name:'Thom'}
}

def notIn(test)
  let isTrue = test.equal(?, true)
  let isFalse = test.equal(?, false)

  10 not in [1,10,30]                    | isFalse
  10 not in data3.numbers                | isFalse
  'name' not in {age:43, name:'Thom'}    | isFalse
  'name' not in data3.person             | isFalse
  'name' not in 'a name value'           | isTrue
  'name' not in data3.stringValue        | isTrue
  'fred' not in ['bill', 'ted']          | isTrue
  'fred' not in data3.names              | isTrue
  'nothing' not in {age:43, name:'Thom'} | isTrue
  'nothing' not in data3.person          | isTrue
  test.done()
end

def bool(test)
  let isTrue = test.equal(?, true)
  let isFalse = test.equal(?, false)

  true and false                          | isFalse
  true or false                           | isTrue
  data1.people[0].age * 2 = 100 and 'yep' | test.equal(?, "yep")
  data1.people[0].age * 2 = 99 or 'nope'  | test.equal(?, "nope")
  'yep' and data1.people[0].age * 2       | test.equal(?, 100)
  'yep' or data1.people[0].age * 2        | test.equal(?, "yep")
  false or data1.people[0].age * 2        | test.equal(?, 100)
  not true and not false                  | isFalse
  not(true or false)                      | isFalse
  not true or not false                   | isTrue
  not(true and false)                     | isTrue
  test.done()
end

def unary(test)
  let isTrue = test.equal(?, true)
  let isFalse = test.equal(?, false)

  let a = "99"

  +1                             | test.equal(?, 1)
  +a                             | test.equal(?, 99)
  -1                             | test.equal(?, -1)
  not false                      | isTrue
  not true                       | isFalse
  not (----10 - 10)              | isTrue
  -data1.people[0].age           | test.equal(?, -50)
  -data1.people[0].age + 10      | test.equal(?, -40)
  not (data1.people[0].age = 25) | isTrue
  test.done()
end

def noneSomeEvaluation(test)
  let isTrue = test.equal(?, true)
  let isFalse = test.equal(?, false)

  true = None          | isFalse
  None != None         | isFalse
  None = None          | isTrue
  bogusValue != None   | isTrue
  bogusValue = None    | isFalse
  bogusValue like None | isTrue

  null like None            | isTrue
  undefined like None       | isTrue
  None like None            | isTrue
  Some like None            | isFalse
  null like null            | isTrue
  undefined like null       | isTrue
  None like null            | isTrue
  Some like null            | isFalse
  null like undefined       | isTrue
  undefined like undefined  | isTrue
  None like undefined       | isTrue
  Some like undefined       | isFalse
  null like Some            | isFalse
  undefined like Some       | isFalse
  None like Some            | isFalse
  Some like Some            | isTrue

  let n = None, s = Some
  null like n               | isTrue
  undefined like n          | isTrue
  n like n                  | isTrue
  s like n                  | isFalse
  null like null            | isTrue
  undefined like null       | isTrue
  n like null               | isTrue
  s like null               | isFalse
  null like undefined       | isTrue
  undefined like undefined  | isTrue
  n like undefined          | isTrue
  s like undefined          | isFalse
  null like s               | isFalse
  undefined like s          | isFalse
  n like s                  | isFalse
  s like s                  | isTrue

  Some("hello")             | isTrue
  Some(undefined)           | isFalse
  None("hello")             | isFalse
  None(undefined)           | isTrue
  Some(Some)                | isTrue
  None(None)                | isTrue
  Some(None)                | isFalse
  None(Some)                | isFalse

  test.done()
end

def conditional(test)
  let script = (data) -> 'cond1' if data.cond1 else
                         'cond2' if data.cond2 else
                         'cond4' unless data.cond3 else
                         'cond3'

  {cond1: true} | script | test.equal(?, "cond1")
  {cond2: true} | script | test.equal(?, "cond2")
  {cond3: true} | script | test.equal(?, "cond3")
  {} | script | test.equal(?, "cond4")
  test.done()
end

def trailingIfStatement(test)
  def test1(value)
    return 'cond 1' if value = 99
    return 'cond 2' unless value = 100
    'cond 3'
  end

  test.equal(test1(99), 'cond1')
  test.equal(test1(0), 'cond3')
  test.equal(test1(100), 'cond2')
  test.done()
end

def ifLetStatement(test)
  def test1(val1, val2, val3)
    if let a = val1, b = val2, c = val3
      {a, b, c} | "%a-%b-%c"
    else if a like None
      "a was None"
    else if b like None
      "b was None"
    else
      "c was None"
    end
  end

  def test2(val)
    if let a = val
      {a} | "%a returned"
    else
      "a was None"
    end
  end

  test.equal(test1("aVal", "bVal", "cVal"), "aVal-bVal-cVal")
  test.equal(test1("aVal"), "b was None")
  test.equal(test1(None, "bVal"), "a was None")
  test.equal(test1("aVal", "bVal"), "c was None")

  test.equal(test2("aVal"), "aVal returned")
  test.equal(test2(), "a was None")
  test.done()
end

def objectLike(test)
  let isTrue = test.equal(?, true)
  let isFalse = test.equal(?, false)

  let person = {
    name: "Thom",
    age: 42,
    title: "Developer"
  }

  let a = 99, b = 'hello'

  person like { name: "Thom", age: 42 } | isTrue
  person like person                    | isTrue
  None like {(a): b}                    | isFalse
  99 like {name: b}                     | isFalse
  test.done()
end

def arrayLike(test)
  let isTrue = test.equal(?, true)
  let isFalse = test.equal(?, false)

  let a = 99, b = 'hello', c = [1, 2, 3]

  [1, 2, 3] like [1, 2]    | isTrue
  [1, 2, 3] like [1, 2, 3] | isTrue
  [1, 2] like [1, 2, 3]    | isFalse
  [] like []               | isTrue
  [] like [a]              | isFalse
  None like [b]            | isFalse
  99 like [1,b,a]          | isFalse
  c like c                 | isTrue
  test.done()
end

def deepPaths(test)
  let root = [{
    colors: ['red', 'green', 'blue'],
    info: {
      description: "this is a description"
    }
  }]

  root[0].colors[1]                   | test.equal(?, "green")
  root[0].info.description            | test.equal(?, "this is a description")
  root[0].info['description']         | test.equal(?, "this is a description")
  root[0].info.notThere               | test.equal(?, undefined)
  (() -> root[1].info['description']) | test.throws
  test.done()
end

def regularExpressions(test)
  let isTrue = test.equal(?, true)
  let isFalse = test.equal(?, false)

  let pattern1 = /dy$/
  let pattern2 = ~/dy$/

  let objectPattern1 = { name: /^Tho/ }
  let objectPattern2 = ~{ name: ~/^Tho/ }
  let objectPattern3 = ~{
    name: ~/White$/,
    age: self > 50,
    colors: ['red', 'green', self]
  }

  let testObject1 = {
    name: 'Fred White', age: 99,
    colors: ['red', 'green', 'yellow']
  }

  let testObject2 = {
    name: 'Fred Black', age: 99,
    colors: ['red', 'green', 'blue']
  }

  "hello" like /^hell/                   | isTrue
  "hello" like ~/^hell/                  | isTrue
  "howdy" like pattern1                  | isTrue
  "however" like pattern1                | isFalse
  "howdy" like pattern2                  | isTrue
  "however" like pattern2                | isFalse
  { name: 'Thomas' } like objectPattern1 | isTrue
  { name: 'Bill' } like objectPattern1   | isFalse
  { name: 'Thomas' } like objectPattern2 | isTrue
  { name: 'Bill' } like objectPattern2   | isFalse
  testObject1 like objectPattern3        | isTrue
  testObject2 like objectPattern3        | isFalse
  test.done()
end

def assignments(test)
  let a = 99
  test.equal(a, 99)

  let a = 99, b = 1000
  test.equal(a + b, 1099)

  let a = 100, b = a + 20, c = b * 2
  test.equal(c, 240)

  test.done()
end

def nestedMatchers(test)
  let isTrue = test.equal(?, true)
  let isFalse = test.equal(?, false)

  let n = None, p = ~(42)

  39 like ~(p)   | isFalse
  42 like ~(p)   | isTrue
  null like ~(n) | isTrue
  42 like ~(n)   | isFalse
  None like ~(n) | isTrue
  test.done()
end

let tests = nodeunit.testCase({
  "Relational Evaluation": relational,
  "Equality Evaluation": equality,
  "'in' Evaluation": inEvaluation,
  "'not in' Evaluation": notIn,
  "Boolean Or/And Evaluation": bool,
  "Unary Evaluation": unary,
  "None/Some Evaluation": noneSomeEvaluation,
  "Conditional Evaluation": conditional,
  "'if let' Evaluation": ifLetStatement,
  "Object Like": objectLike,
  "Array Like": arrayLike,
  "Deep Paths": deepPaths,
  "Regular Expressions": regularExpressions,
  "Assignments": assignments,
  "Nested Matchers": nestedMatchers
})

export tests
