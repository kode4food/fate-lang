from '../Types' import isObject, isArray

from '../runtime/Pattern'
import isPattern, definePattern

export from '../runtime/Pattern'
import isNothing as Nothing
     , isSomething as Something

from './support' import isA, setProperty

# Warning: this module assumes JavaScript-specific methods
#
#   Array.prototype.length

export let String = ~isA(it, 'string')
export let EmptyString = ~''

export let NonEmptyString = ~(
  isA(it, 'string') and it.length > 0
)

export
let Number = ~isA(it, 'number')
  , PositiveNumber = ~(it > 0 and isA(it, 'number'))
  , NonNegativeNumber = ~(it ≥ 0 and isA(it, 'number'))
  , NegativeNumber = ~(it < 0 and isA(it, 'number'))
  , Integer = ~(it mod 1 = 0 and isA(it, 'number'))

export let PositiveInteger = ~(
  it > 0 and it mod 1 = 0 and isA(it, 'number')
)

export let NonNegativeInteger = ~(
  it ≥ 0 and it mod 1 = 0 and isA(it, 'number')
)

export let NegativeInteger = ~(
  it < 0 and it mod 1 = 0 and isA(it, 'number')
)

export
let Array = definePattern(isArray)
  , EmptyArray = ~(isArray(it) and it.length = 0)
  , NonEmptyArray = ~(isArray(it) and it.length > 0)
  , Object = definePattern(isObject)
  , Boolean = ~isA(it, 'boolean')
  , Function = ~isA(it, 'function')

export def ArrayOf(elementPattern)
  let checker = definePattern(value →
    return false unless isArray(value)
    [
      for item in value
      where not elementPattern(item)
    ].length = 0
  )

  def decorate(pattern)
    setProperty(pattern, 'MinLength', minLength →
      (pattern and> value → value.length ≥ minLength) | decorate
    )

    setProperty(pattern, 'MaxLength', maxLength →
      (pattern and> value → value.length ≤ maxLength) | decorate
    )

    pattern
  end

  return decorate(Array) unless isPattern(elementPattern)
  decorate(checker)
end
