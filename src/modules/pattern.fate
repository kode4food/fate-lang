from '../Runtime' import isPattern, definePattern

export from '../Runtime'
import isFalse as False
     , isTrue as True
     , isNothing as Nothing
     , isSomething as Something
     , isObject as Object
     , isArray as Array

from './support' import isA, setProperty

# Warning: this module assumes JavaScript-specific methods
#
#   Array.prototype.length

export let String = ~isA(it, 'string')
export let EmptyString = ~''

export let NonEmptyString = ~(
  isA(it, 'string') and it.length > 0
)

export
let Number = ~isA(it, 'number')
  , PositiveNumber = ~(it > 0 and isA(it, 'number'))
  , NonNegativeNumber = ~(it ≥ 0 and isA(it, 'number'))
  , NegativeNumber = ~(it < 0 and isA(it, 'number'))
  , Integer = ~(it mod 1 = 0 and isA(it, 'number'))

export let PositiveInteger = ~(
  it > 0 and it mod 1 = 0 and isA(it, 'number')
)

export let NonNegativeInteger = ~(
  it ≥ 0 and it mod 1 = 0 and isA(it, 'number')
)

export let NegativeInteger = ~(
  it < 0 and it mod 1 = 0 and isA(it, 'number')
)

export
let EmptyArray = ~(Array(it) and it.length = 0)
  , NonEmptyArray = ~(Array(it) and it.length > 0)
  , Boolean = ~isA(it, 'boolean')
  , Function = ~isA(it, 'function')

export def ArrayOf(elementPattern)
  let checker = definePattern(value →
    return false unless Array(value)
    [
      for item in value
      where not elementPattern(item)
    ].length = 0
  )

  def decorate(pattern)
    setProperty(pattern, 'MinLength', minLength →
      (pattern && value → value.length ≥ minLength) | decorate
    )

    setProperty(pattern, 'MaxLength', maxLength →
      (pattern && value → value.length ≤ maxLength) | decorate
    )

    pattern
  end

  return decorate(Array) unless isPattern(elementPattern)
  decorate(checker)
end
